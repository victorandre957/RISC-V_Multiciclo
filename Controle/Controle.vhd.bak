library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity risc_v_control is
    port (
        clk       : in std_logic;
        rst       : in std_logic;
        opcode    : in std_logic_vector(6 downto 0);
        zero_flag : in std_logic;

        -- Saídas de controle
        EscrevePCCond : out std_logic;
        EscrevePC     : out std_logic;
        LouD          : out std_logic;
        EscreveMem    : out std_logic;
        LeMem         : out std_logic;
        EscreveIR     : out std_logic;
        OrigPC        : out std_logic_vector(1 downto 0);
        ALUop         : out std_logic_vector(3 downto 0);
        OrigAULA      : out std_logic;
        OrigBULA      : out std_logic;
        EscrevePCB    : out std_logic;
        EscreveReg    : out std_logic;
        Mem2Reg       : out std_logic
    );
end entity;

architecture fsm of risc_v_control is
    type state_type is (IFetch, Decode, MemRead, MemWrite, Execute, WriteBack, BEQ, Jump);
    signal state, next_state : state_type;

    -- Adicionar contador para o estado IFetch
    signal fetch_counter : integer range 0 to 1 := 0;

    -- Definir os opcodes das instruções RISC-V
    constant LW   : std_logic_vector(6 downto 0) := "0000011";
    constant SW   : std_logic_vector(6 downto 0) := "0100011";
    constant R_TYPE : std_logic_vector(6 downto 0) := "0110011";
    constant I_TYPE : std_logic_vector(6 downto 0) := "0010011";
    constant JAL : std_logic_vector(6 downto 0) := "1101111";
    constant JALR : std_logic_vector(6 downto 0) := "1100111";
    constant BRANCH : std_logic_vector(6 downto 0) := "1100011";
    constant AUIPC : std_logic_vector(6 downto 0) := "0010111";
    constant LUI : std_logic_vector(6 downto 0) := "0110111";

begin
    -- Estado síncrono com clock
    process (clk, rst)
    begin
        if rst = '1' then
            state <= IFetch;
            fetch_counter <= 0;
        elsif rising_edge(clk) then
            state <= next_state;
            if state = IFetch then
                fetch_counter <= fetch_counter + 1;
            else
                fetch_counter <= 0;
            end if;
        end if;
    end process;

    -- Máquina de estados do controle
    process (state, opcode, zero_flag, fetch_counter)
    begin
        -- Inicialização das saídas de controle
        EscrevePCCond <= '0';
        EscrevePC <= '0';
        LouD <= '0';
        EscreveMem <= '0';
        LeMem <= '0';
        EscreveIR <= '0';
        OrigPC <= (others => '0');
        ALUop <= (others => '0');
        OrigAULA <= '0';
        OrigBULA <= '0';
        EscrevePCB <= '0';
        EscreveReg <= '0';
        Mem2Reg <= '0';

        case state is
            -- Instrução Fetch (IFetch)
            when IFetch =>
                LeMem <= '1';          -- Ler memória para buscar instrução
                EscreveIR <= '1';      -- Escrever no IR (Instruction Register)
                EscrevePC <= '1';      -- Incrementar PC
                if fetch_counter = 1 then
                    next_state <= Decode;
                else
                    next_state <= IFetch;
                end if;

            -- Decodificação
            when Decode =>
                case opcode is
                    when LW =>
                        OrigBULA <= '1';   -- Usar imediato para cálculo de endereço
                        next_state <= MemRead;
                    when SW =>
                        OrigBULA <= '1';   -- Usar imediato para cálculo de endereço
                        next_state <= MemWrite;
                    when R_TYPE =>
                        next_state <= Execute;
                    when I_TYPE =>
                        OrigBULA <= '1';   -- Usar imediato
                        next_state <= Execute;
                    when JAL =>
                        next_state <= Jump;
                    when JALR =>
                        next_state <= Jump;
                    when BRANCH =>
                        next_state <= BEQ;
                    when AUIPC | LUI =>
                        OrigBULA <= '1';   -- AUIPC e LUI usam imediato
                        next_state <= Execute;
                    when others =>
                        next_state <= IFetch;
                end case;

            -- MemRead (carregar valor da memória)
            when MemRead =>
                LouD <= '1';              -- Carregar valor da memória
                next_state <= WriteBack;

            -- MemWrite (armazenar valor na memória)
            when MemWrite =>
                EscreveMem <= '1';        -- Escrever na memória
                next_state <= IFetch;

            -- Execute (instruções ALU)
            when Execute =>
                case opcode is
                    when R_TYPE =>
                        ALUop <= "0010";  -- Definir operação ALU para tipo-R
                        next_state <= WriteBack;
                    when I_TYPE =>
                        ALUop <= "0010";  -- Definir operação ALU para tipo-I
                        next_state <= WriteBack;
                    when AUIPC | LUI =>
                        ALUop <= "0010";  -- Definir operação ALU para AUIPC e LUI
                        next_state <= WriteBack;
                    when others =>
                        next_state <= IFetch;
                end case;

            -- Controle de BEQ
            when BEQ =>
                if (zero_flag = '1') then
                    EscrevePCCond <= '1';  -- Atualizar PC se condicional satisfeita (e.g., BEQ)
                end if;
                next_state <= IFetch;

            -- Controle de Jump (JAL/JALR)
            when Jump =>
                OrigPC <= "10";           -- Definir origem do PC para JAL/JALR
                EscrevePCB <= '1';        -- Escrever no PC
                EscreveReg <= '1';        -- Escrever no registrador
                next_state <= IFetch;

            -- WriteBack (escreve o resultado no registrador)
            when WriteBack =>
                EscreveReg <= '1';        -- Ativa escrita no registrador
                if opcode = LW then
                    Mem2Reg <= '1';       -- O valor vem da memória
                end if;
                next_state <= IFetch;

            when others =>
                next_state <= IFetch;
        end case;
    end process;
end architecture;


